/**
 * Generated by orval v7.8.0 üç∫
 * Do not edit manually.
 * Krisefikser API
 * This API exposes endpoints for the Krisefikser application.
 * OpenAPI spec version: 1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/vue-query';
import type {
  DataTag,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationReturnType,
  UseQueryOptions,
  UseQueryReturnType
} from '@tanstack/vue-query';

import {
  computed,
  unref
} from 'vue';
import type {
  MaybeRef
} from 'vue';

import type {
  GetAllProductTypesParams,
  PageProductType,
  ProductType,
  ProductTypeDto,
  SearchProductTypesParams
} from '.././model';

import { customInstance } from '../../axios';
import type { ErrorType , BodyType } from '../../axios';


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



export const getProductType = (
    id: MaybeRef<string>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      id = unref(id);
      
      return customInstance<ProductType>(
      {url: `http://localhost:8080/api/product-types/${id}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetProductTypeQueryKey = (id: MaybeRef<string>,) => {
    return ['http:','localhost:8080','api','product-types',id] as const;
    }

    
export const getGetProductTypeQueryOptions = <TData = Awaited<ReturnType<typeof getProductType>>, TError = ErrorType<unknown>>(id: MaybeRef<string>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductType>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  getGetProductTypeQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProductType>>> = ({ signal }) => getProductType(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: computed(() => !!(unref(id))), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getProductType>>, TError, TData> 
}

export type GetProductTypeQueryResult = NonNullable<Awaited<ReturnType<typeof getProductType>>>
export type GetProductTypeQueryError = ErrorType<unknown>



export function useGetProductType<TData = Awaited<ReturnType<typeof getProductType>>, TError = ErrorType<unknown>>(
 id: MaybeRef<string>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductType>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetProductTypeQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}



export const updateProductType = (
    id: MaybeRef<string>,
    productTypeDto: MaybeRef<ProductTypeDto>,
 options?: SecondParameter<typeof customInstance>,) => {
      id = unref(id);
productTypeDto = unref(productTypeDto);
      
      return customInstance<ProductType>(
      {url: `http://localhost:8080/api/product-types/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: productTypeDto
    },
      options);
    }
  


export const getUpdateProductTypeMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateProductType>>, TError,{id: string;data: BodyType<ProductTypeDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateProductType>>, TError,{id: string;data: BodyType<ProductTypeDto>}, TContext> => {
    
const mutationKey = ['updateProductType'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateProductType>>, {id: string;data: BodyType<ProductTypeDto>}> = (props) => {
          const {id,data} = props ?? {};

          return  updateProductType(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateProductTypeMutationResult = NonNullable<Awaited<ReturnType<typeof updateProductType>>>
    export type UpdateProductTypeMutationBody = BodyType<ProductTypeDto>
    export type UpdateProductTypeMutationError = ErrorType<unknown>

    export const useUpdateProductType = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateProductType>>, TError,{id: string;data: BodyType<ProductTypeDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof updateProductType>>,
        TError,
        {id: string;data: BodyType<ProductTypeDto>},
        TContext
      > => {

      const mutationOptions = getUpdateProductTypeMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    export const deleteProductType = (
    id: MaybeRef<string>,
 options?: SecondParameter<typeof customInstance>,) => {
      id = unref(id);
      
      return customInstance<void>(
      {url: `http://localhost:8080/api/product-types/${id}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteProductTypeMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteProductType>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteProductType>>, TError,{id: string}, TContext> => {
    
const mutationKey = ['deleteProductType'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteProductType>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  deleteProductType(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteProductTypeMutationResult = NonNullable<Awaited<ReturnType<typeof deleteProductType>>>
    
    export type DeleteProductTypeMutationError = ErrorType<unknown>

    export const useDeleteProductType = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteProductType>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof deleteProductType>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getDeleteProductTypeMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    export const getAllProductTypes = (
    params: MaybeRef<GetAllProductTypesParams>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      params = unref(params);
      
      return customInstance<PageProductType>(
      {url: `http://localhost:8080/api/product-types`, method: 'GET',
        params: unref(params), signal
    },
      options);
    }
  

export const getGetAllProductTypesQueryKey = (params: MaybeRef<GetAllProductTypesParams>,) => {
    return ['http:','localhost:8080','api','product-types', ...(params ? [params]: [])] as const;
    }

    
export const getGetAllProductTypesQueryOptions = <TData = Awaited<ReturnType<typeof getAllProductTypes>>, TError = ErrorType<unknown>>(params: MaybeRef<GetAllProductTypesParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllProductTypes>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  getGetAllProductTypesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllProductTypes>>> = ({ signal }) => getAllProductTypes(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAllProductTypes>>, TError, TData> 
}

export type GetAllProductTypesQueryResult = NonNullable<Awaited<ReturnType<typeof getAllProductTypes>>>
export type GetAllProductTypesQueryError = ErrorType<unknown>



export function useGetAllProductTypes<TData = Awaited<ReturnType<typeof getAllProductTypes>>, TError = ErrorType<unknown>>(
 params: MaybeRef<GetAllProductTypesParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllProductTypes>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllProductTypesQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}



export const createProductType = (
    productTypeDto: MaybeRef<ProductTypeDto>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      productTypeDto = unref(productTypeDto);
      
      return customInstance<ProductType>(
      {url: `http://localhost:8080/api/product-types`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: productTypeDto, signal
    },
      options);
    }
  


export const getCreateProductTypeMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createProductType>>, TError,{data: BodyType<ProductTypeDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createProductType>>, TError,{data: BodyType<ProductTypeDto>}, TContext> => {
    
const mutationKey = ['createProductType'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createProductType>>, {data: BodyType<ProductTypeDto>}> = (props) => {
          const {data} = props ?? {};

          return  createProductType(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateProductTypeMutationResult = NonNullable<Awaited<ReturnType<typeof createProductType>>>
    export type CreateProductTypeMutationBody = BodyType<ProductTypeDto>
    export type CreateProductTypeMutationError = ErrorType<unknown>

    export const useCreateProductType = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createProductType>>, TError,{data: BodyType<ProductTypeDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof createProductType>>,
        TError,
        {data: BodyType<ProductTypeDto>},
        TContext
      > => {

      const mutationOptions = getCreateProductTypeMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    export const searchProductTypes = (
    params: MaybeRef<SearchProductTypesParams>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      params = unref(params);
      
      return customInstance<ProductType[]>(
      {url: `http://localhost:8080/api/product-types/search`, method: 'GET',
        params: unref(params), signal
    },
      options);
    }
  

export const getSearchProductTypesQueryKey = (params: MaybeRef<SearchProductTypesParams>,) => {
    return ['http:','localhost:8080','api','product-types','search', ...(params ? [params]: [])] as const;
    }

    
export const getSearchProductTypesQueryOptions = <TData = Awaited<ReturnType<typeof searchProductTypes>>, TError = ErrorType<unknown>>(params: MaybeRef<SearchProductTypesParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchProductTypes>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  getSearchProductTypesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof searchProductTypes>>> = ({ signal }) => searchProductTypes(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof searchProductTypes>>, TError, TData> 
}

export type SearchProductTypesQueryResult = NonNullable<Awaited<ReturnType<typeof searchProductTypes>>>
export type SearchProductTypesQueryError = ErrorType<unknown>



export function useSearchProductTypes<TData = Awaited<ReturnType<typeof searchProductTypes>>, TError = ErrorType<unknown>>(
 params: MaybeRef<SearchProductTypesParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchProductTypes>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSearchProductTypesQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}



